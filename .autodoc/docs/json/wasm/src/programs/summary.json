{
  "folderName": "programs",
  "folderPath": ".autodoc/docs/json/wasm/src/programs",
  "url": "https://github.com/AleoHQ/aleo/.autodoc/docs/json/wasm/src/programs",
  "files": [
    {
      "fileName": "fee.rs",
      "filePath": "wasm/src/programs/fee.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/fee.rs",
      "summary": "This code defines a WebAssembly (WASM) representation of an Aleo function fee execution response, which is used when creating an on-chain program execution transaction. The `FeeExecution` struct is a wrapper around the native `FeeNative` type, providing a WASM-compatible interface for interacting with the fee execution response.\n\nThe `FeeExecution` struct has a single method, `fee()`, which returns the amount of the fee as a `u64` value. This method is useful for retrieving the fee amount when creating a transaction that requires a fee.\n\nThe `Deref` trait is implemented for `FeeExecution`, allowing it to be dereferenced to its inner `FeeNative` type. This makes it easy to work with the underlying native type when needed.\n\nAdditionally, the `From` trait is implemented for converting between `FeeNative` and `FeeExecution` types. This allows for seamless conversion between the native and WASM representations of the fee execution response.\n\nHere's an example of how this code might be used in the larger project:\n\n```rust\n// Create a FeeNative instance\nlet fee_native = FeeNative::new(100);\n\n// Convert the FeeNative instance to a FeeExecution instance\nlet fee_execution = FeeExecution::from(fee_native);\n\n// Get the fee amount from the FeeExecution instance\nlet fee_amount = fee_execution.fee().unwrap();\n\n// Convert the FeeExecution instance back to a FeeNative instance\nlet fee_native_converted = FeeNative::from(fee_execution);\n```\n\nIn summary, this code provides a WASM-compatible representation of an Aleo function fee execution response, allowing for easy interaction with the fee execution response when creating on-chain program execution transactions.",
      "questions": "1. **Question**: What is the purpose of the `FeeExecution` struct and how is it used in the Aleo project?\n   **Answer**: The `FeeExecution` struct is a WebAssembly representation of an Aleo function fee execution response. It is returned by the execution of the `fee` function in `credits.aleo` and is required as part of an on-chain program execution transaction if a fee is specified.\n\n2. **Question**: How does the `Deref` trait implementation for `FeeExecution` work and what is its purpose?\n   **Answer**: The `Deref` trait implementation for `FeeExecution` allows the struct to be automatically dereferenced to its inner `FeeNative` type. This makes it easier to access the underlying `FeeNative` methods and properties without explicitly calling a method to access it.\n\n3. **Question**: What is the purpose of the `From` trait implementations for `FeeExecution` and `FeeNative`?\n   **Answer**: The `From` trait implementations for `FeeExecution` and `FeeNative` allow for easy conversion between the two types. This makes it convenient to convert a `FeeNative` instance to a `FeeExecution` instance and vice versa, simplifying the process of working with both types in the Aleo project."
    },
    {
      "fileName": "macros.rs",
      "filePath": "wasm/src/programs/macros.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/macros.rs",
      "summary": "The code provided contains three macros that are part of the Aleo project, which is a platform for building private applications. These macros are used to execute programs, generate inclusion proofs, and generate fee inclusion proofs.\n\n1. `execute_program!` macro: This macro is used to execute a program with the given inputs, program ID, function name, and private key. It first converts the inputs into a native format and then loads the process. It adds the program to the process and authorizes the execution using the provided private key. Finally, it executes the program and returns the result along with the process. This macro can be used in the larger project to execute programs securely and privately.\n\n   Example usage:\n   ```\n   let (result, process) = execute_program!(inputs, program_id, function_name, private_key)?;\n   ```\n\n2. `inclusion_proof!` macro: This macro is used to generate an inclusion proof for a given execution and URL. It prepares the execution using the provided inclusion object and URL, and then generates the proof using the `prove_execution` method. This macro can be used in the larger project to generate inclusion proofs, which are essential for proving the correctness of a program's execution without revealing any sensitive information.\n\n   Example usage:\n   ```\n   let execution_proof = inclusion_proof!(inclusion, execution, url)?;\n   ```\n\n3. `fee_inclusion_proof!` macro: This macro is used to generate a fee inclusion proof for a given process, private key, fee record, fee microcredits, and submission URL. It first executes the fee using the provided private key, fee record, and fee microcredits. Then, it prepares the assignments using the inclusion object and submission URL. Finally, it generates the fee inclusion proof using the `prove_fee` method. This macro can be used in the larger project to generate fee inclusion proofs, which are essential for proving the correctness of fee payments without revealing any sensitive information.\n\n   Example usage:\n   ```\n   let fee_proof = fee_inclusion_proof!(process, private_key, fee_record, fee_microcredits, submission_url)?;\n   ```",
      "questions": "1. **Question:** What is the purpose of the `execute_program!` macro and what are its input parameters?\n   **Answer:** The `execute_program!` macro is used to execute a given program with specified inputs, function, and private key. The input parameters are `$inputs` (a list of input strings), `$program` (the program ID as a string), `$function` (the function name as a string), and `$private_key` (the private key for authorization).\n\n2. **Question:** How does the `inclusion_proof!` macro work and what are its input parameters?\n   **Answer:** The `inclusion_proof!` macro is used to generate an inclusion proof for a given execution. The input parameters are `$inclusion` (an instance of the inclusion proof), `$execution` (the execution to be proved), and `$url` (the URL for preparing the execution).\n\n3. **Question:** What is the purpose of the `fee_inclusion_proof!` macro and what are its input parameters?\n   **Answer:** The `fee_inclusion_proof!` macro is used to generate a fee inclusion proof for a given process, private key, fee record, fee microcredits, and submission URL. The input parameters are `$process` (the process instance), `$private_key` (the private key for authorization), `$fee_record` (the fee record as a string), `$fee_microcredits` (the fee microcredits value), and `$submission_url` (the URL for preparing the fee)."
    },
    {
      "fileName": "mod.rs",
      "filePath": "wasm/src/programs/mod.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/mod.rs",
      "summary": "This code is part of the Aleo library, which is a free software licensed under the GNU General Public License. The Aleo library is designed to be useful for various purposes, but it does not come with any warranty or guarantee of fitness for a particular purpose.\n\nThe code is organized into several modules, each serving a specific purpose within the larger Aleo project. These modules are:\n\n1. `macros`: This module contains macros that are used throughout the Aleo library. Macros are reusable code snippets that can be invoked with a simple syntax, allowing for code reuse and simplification.\n\n2. `fee`: This module deals with the fee structure in the Aleo network. It defines how fees are calculated and handled within the system. By importing this module with `pub use fee::*`, all the components of the `fee` module are made available for use in other parts of the Aleo library.\n\n3. `response`: This module handles the responses generated by various operations in the Aleo network. It defines the structure and format of these responses, as well as any associated error handling. By importing this module with `pub use response::*`, all the components of the `response` module are made available for use in other parts of the Aleo library.\n\n4. `program`: This module deals with the programs that run on the Aleo network. It defines the structure and execution of these programs, as well as any associated data and metadata. By importing this module with `pub use program::*`, all the components of the `program` module are made available for use in other parts of the Aleo library.\n\n5. `transaction`: This module handles the transactions that occur within the Aleo network. It defines the structure, validation, and processing of these transactions, as well as any associated data and metadata. By importing this module with `pub use transaction::*`, all the components of the `transaction` module are made available for use in other parts of the Aleo library.\n\nOverall, this code serves as a foundation for the Aleo library, providing essential functionality for various aspects of the Aleo network, such as fee calculation, response handling, program execution, and transaction processing.",
      "questions": "1. **Question**: What is the purpose of the Aleo library?\n   **Answer**: The Aleo library is a software package that provides various functionalities, but the specific purpose is not clear from the provided code. More information can be found in the project documentation or by examining the modules included in the library.\n\n2. **Question**: What are the main modules included in the Aleo library and what do they do?\n   **Answer**: The Aleo library includes the following modules: `fee`, `response`, `program`, and `transaction`. The specific functionalities of these modules are not clear from the provided code, but they can be inferred from their names and by examining their respective source files.\n\n3. **Question**: Under which license is the Aleo library distributed?\n   **Answer**: The Aleo library is distributed under the GNU General Public License, either version 3 of the License or any later version, as stated in the code comments."
    },
    {
      "fileName": "program.rs",
      "filePath": "wasm/src/programs/program.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/program.rs",
      "summary": "The code in this file provides a WebAssembly (WASM) representation of an Aleo program, which is required to create an Execution or Deployment transaction. It includes several convenience methods for enumerating available functions and each function's inputs in a JavaScript object for usage in the creation of web forms for input capture.\n\nThe `Program` struct is the main component of this file, and it provides several methods to interact with Aleo programs:\n\n- `from_string(program: &str)`: Creates a `Program` instance from a program string.\n- `to_string(&self)`: Returns a string representation of the program.\n- `get_functions(&self)`: Returns a JavaScript array of function names in the program.\n- `get_function_inputs(&self, function_name: String)`: Returns a JavaScript object representation of the function inputs and types, which can be used to generate a web form to capture user inputs for an execution of a function.\n- `get_record_members(&self, record_name: String)`: Returns a JavaScript object representation of a program record and its types.\n- `get_struct_members(&self, struct_name: String)`: Returns a JavaScript object representation of a program struct and its types.\n\nHere's an example of how to use the `Program` struct:\n\n```rust\nlet program_string = ProgramNative::credits().unwrap().to_string();\nlet program = Program::from_string(&program_string).unwrap();\nlet functions = program.get_functions();\nlet function_inputs = program.get_function_inputs(\"transfer\".to_string()).unwrap();\nlet record_members = program.get_record_members(\"credits\".to_string()).unwrap();\nlet struct_members = program.get_struct_members(\"token_metadata\".to_string()).unwrap();\n```\n\nThis code can be used in the larger Aleo project to interact with Aleo programs in a web environment, making it easier to create web forms for input capture and work with Aleo programs in a JavaScript context.",
      "questions": "1. **Question:** What is the purpose of the `Program` struct and its associated methods in this code?\n\n   **Answer:** The `Program` struct is a WebAssembly representation of an Aleo program. It is required to create an Execution or Deployment transaction and includes several convenience methods for enumerating available functions and each function's inputs in a JavaScript object for usage in the creation of web forms for input capture.\n\n2. **Question:** How does the `get_function_inputs` method work and what does it return?\n\n   **Answer:** The `get_function_inputs` method takes a function name as input and returns a JavaScript array of objects representing the function inputs and their types. This can be used to generate a web form to capture user inputs for an execution of a function.\n\n3. **Question:** How can I get a JavaScript object representation of a program record and its types?\n\n   **Answer:** You can use the `get_record_members` method by providing the record name as input. This method returns a JavaScript object representation of the program record and its types."
    },
    {
      "fileName": "response.rs",
      "filePath": "wasm/src/programs/response.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/response.rs",
      "summary": "The code in this file defines a WebAssembly (WASM) representation of an Aleo function execution response. This is useful when interacting with Aleo functions off-chain, as it provides a way to retrieve the outputs of the function execution in a format that can be easily used in a web environment.\n\nThe `ExecutionResponse` struct is a wrapper around the native `ResponseNative` type, which is imported from the `crate::types` module. The `ExecutionResponse` struct implements the `Deref` trait, allowing it to be dereferenced to its inner `ResponseNative` type.\n\nThe `ExecutionResponse` struct provides a single method, `get_outputs`, which returns a `js_sys::Array` containing the outputs of the executed function. This method iterates over the outputs of the native response, converting each output to a `JsValue` and adding it to the array. This makes it easy to work with the outputs in JavaScript code.\n\nAdditionally, the `ExecutionResponse` struct implements the `From` trait for both `ResponseNative` and `ExecutionResponse`. This allows for easy conversion between the native and WASM representations of the execution response.\n\nHere's an example of how the `ExecutionResponse` struct might be used in a larger project:\n\n```rust\n// Assume we have a function `execute_aleo_function` that takes some input and returns a ResponseNative\nlet native_response: ResponseNative = execute_aleo_function(input);\n\n// Convert the native response to a WASM-compatible ExecutionResponse\nlet wasm_response: ExecutionResponse = ExecutionResponse::from(native_response);\n\n// Retrieve the outputs as a JavaScript array\nlet outputs: js_sys::Array = wasm_response.get_outputs();\n\n// Now the outputs can be easily used in JavaScript code\n```",
      "questions": "1. **What is the purpose of the `ExecutionResponse` struct and how is it used?**\n\n   The `ExecutionResponse` struct is a WebAssembly representation of an Aleo function execution response. It is returned by the execution of an Aleo function off-chain and provides methods for retrieving the outputs of the function execution.\n\n2. **How does the `get_outputs` method work and what does it return?**\n\n   The `get_outputs` method iterates through the outputs of the executed function and creates a new JavaScript array with the outputs as strings. It returns this JavaScript array.\n\n3. **What is the purpose of the `Deref` implementation for `ExecutionResponse`?**\n\n   The `Deref` implementation for `ExecutionResponse` allows the struct to be automatically dereferenced to its inner `ResponseNative` type, providing access to the methods and fields of `ResponseNative` directly on an `ExecutionResponse` instance."
    },
    {
      "fileName": "transaction.rs",
      "filePath": "wasm/src/programs/transaction.rs",
      "url": "https://github.com/AleoHQ/aleo/wasm/src/programs/transaction.rs",
      "summary": "This code defines a `Transaction` struct and its associated methods for the Aleo project. The `Transaction` struct represents an Aleo transaction, which is created when generating an on-chain function deployment or execution. It is the object that should be submitted to the Aleo Network to deploy or execute a function.\n\nThe `Transaction` struct has the following methods:\n\n- `from_string`: Creates a `Transaction` instance from a string representation of a transaction. This is useful when receiving a transaction as a string from an external source and needing to convert it into a `Transaction` object.\n    ```rust\n    let transaction = Transaction::from_string(transaction_string).unwrap();\n    ```\n\n- `to_string`: Returns the string representation of the `Transaction` instance. This is useful when needing to submit the transaction to the Aleo Network as a string in the `POST` data.\n    ```rust\n    let transaction_string = transaction.to_string();\n    ```\n\n- `transaction_id`: Returns the transaction ID, which is the Merkle root of the transaction's inclusion proof. This ID can be used to query the status of the transaction on the Aleo Network to see if it was successful.\n    ```rust\n    let transaction_id = transaction.transaction_id();\n    ```\n\n- `transaction_type`: Returns the type of the transaction as a string, either \"deploy\" or \"execute\".\n    ```rust\n    let transaction_type = transaction.transaction_type();\n    ```\n\nThe code also provides implementations for converting between the `Transaction` struct and its native representation, `TransactionNative`. This is useful for interoperability between the WebAssembly and native Rust code.\n\nLastly, the code includes a test module that demonstrates how to use the `Transaction` struct and its methods, ensuring the correct functionality of the code.",
      "questions": "1. **Question**: What is the purpose of the `Transaction` struct and its methods in this code?\n   **Answer**: The `Transaction` struct represents an Aleo transaction in WebAssembly. It provides methods to create a transaction from a string, get the transaction as a string, get the transaction ID, and get the transaction type (either \"deploy\" or \"execute\").\n\n2. **Question**: How does the code handle the conversion between `Transaction` and `TransactionNative`?\n   **Answer**: The code provides `From` trait implementations for converting between `Transaction` and `TransactionNative`. The `From<Transaction>` implementation for `TransactionNative` extracts the inner `TransactionNative` from the `Transaction`, and the `From<TransactionNative>` implementation for `Transaction` wraps the `TransactionNative` in a `Transaction` struct.\n\n3. **Question**: How are errors handled when parsing a transaction from a string?\n   **Answer**: Errors are handled using the `Result` type. When parsing a transaction from a string using the `from_str` method, if an error occurs, it returns a `Result` with an `Err` variant containing a `String` describing the error."
    }
  ],
  "folders": [],
  "summary": "The code in the `.autodoc/docs/json/wasm/src/programs` folder provides WebAssembly (WASM) representations and utilities for working with Aleo programs, transactions, and fees. These representations are essential for creating on-chain program execution transactions and interacting with Aleo functions in a web environment.\n\nFor example, the `fee.rs` file defines a `FeeExecution` struct that wraps around the native `FeeNative` type, providing a WASM-compatible interface for interacting with the fee execution response. This is useful when creating a transaction that requires a fee, as shown in the following example:\n\n```rust\nlet fee_native = FeeNative::new(100);\nlet fee_execution = FeeExecution::from(fee_native);\nlet fee_amount = fee_execution.fee().unwrap();\nlet fee_native_converted = FeeNative::from(fee_execution);\n```\n\nThe `macros.rs` file contains three macros that are used to execute programs, generate inclusion proofs, and generate fee inclusion proofs. These macros simplify the process of executing programs securely and privately, generating inclusion proofs for proving the correctness of a program's execution, and generating fee inclusion proofs for proving the correctness of fee payments.\n\nThe `mod.rs` file serves as a foundation for the Aleo library, providing essential functionality for various aspects of the Aleo network, such as fee calculation, response handling, program execution, and transaction processing.\n\nThe `program.rs` file provides a `Program` struct with several methods for interacting with Aleo programs in a web environment. This makes it easier to create web forms for input capture and work with Aleo programs in a JavaScript context, as shown in the following example:\n\n```rust\nlet program_string = ProgramNative::credits().unwrap().to_string();\nlet program = Program::from_string(&program_string).unwrap();\nlet functions = program.get_functions();\nlet function_inputs = program.get_function_inputs(\"transfer\".to_string()).unwrap();\nlet record_members = program.get_record_members(\"credits\".to_string()).unwrap();\nlet struct_members = program.get_struct_members(\"token_metadata\".to_string()).unwrap();\n```\n\nThe `response.rs` file defines a `ExecutionResponse` struct that provides a WASM-compatible representation of an Aleo function execution response. This allows for easy interaction with the function execution response when creating on-chain program execution transactions.\n\nFinally, the `transaction.rs` file defines a `Transaction` struct for representing Aleo transactions, which is essential for generating on-chain function deployment or execution. The `Transaction` struct provides methods for creating and interacting with Aleo transactions, as shown in the following example:\n\n```rust\nlet transaction = Transaction::from_string(transaction_string).unwrap();\nlet transaction_string = transaction.to_string();\nlet transaction_id = transaction.transaction_id();\nlet transaction_type = transaction.transaction_type();\n```\n\nIn summary, the code in this folder provides essential functionality for working with Aleo programs, transactions, and fees in a web environment, making it easier to create and interact with on-chain program execution transactions.",
  "questions": ""
}